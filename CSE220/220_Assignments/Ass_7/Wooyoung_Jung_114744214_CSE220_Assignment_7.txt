# Wooyoung Jung 114744214- CSE220 Assignment 7

# 1. Write a program that does the following: 
#       a. Reads ten integers into an array
#       b. Prints out the elements of the array, one per line.
#       c. Sorts the integers in the array, without using another array.
#       d. Prints out the elements of the array, one per line.
#
#   The output of your program should include prompts and messages, and the code should include meaningful comments.

.data
        init_prompt: .asciiz "Enter ten integers, one followed by the Enter key. \n"
        input_prompt: .asciiz "Enter an integer: "
        print_input_prompt: .asciiz "\nInput array before sorting: \n"
        print_output_prompt: .asciiz "\nInput array after sorting: \n"

        array: .space 40        # allocate 40 bytes for the array (10 integers of 4 bytes, or 32 bits each)

.text
main:
    jal read_input

    la $a0, print_input_prompt
    li $v0, 4
    syscall             # print pre-sort prompt
    jal print_array     # print original array

    jal sort            # run sorting algorithm

    la $a0, print_output_prompt
    li $v0, 4
    syscall             # print post-sort prompt
    jal print_array     # print sorted array

    j terminate         # terminate execution

read_input:
    addi $sp, $sp, -12      # allocate space for 3 registers on the stack
    sw $t0, 8($sp)          # stack.push($t0)
    sw $t1, 4($sp)          # stack.push($t1)
    sw $t2, 0($sp)          # stack.push($t2)

    la $t0, array           # int *p = &array[0]
    li $t1, 0               # int counter = 0
    li $t2, 10              # int limit = 10
    
    la $a0, init_prompt
    li $v0, 4
    syscall                 # print initial prompt

    loop:
        la $a0, input_prompt
        li $v0, 4
        syscall             # print input prompt

        li $v0, 5
        syscall

        sb $v0, 0($t0)      # read each input into each index of the element

        addi $t0, $t0, 4    # p++ to point to next element
        addi $t1, $t1, 1    # counter++
    blt $t1, $t2, loop      # loop while counter < limit

    lw $t2, 0($sp)          # stack.pop($t2)
    lw $t1, 4($sp)          # stack.pop($t1)
    lw $t0, 8($sp)          # stack.pop($t0)
    addi $sp, $sp, 12       # deallocate stack space
    
    jr $ra                  # return to caller

print_array:
    addi $sp, $sp, -12      # allocate space for 3 registers on the stack
    sw $t0, 8($sp)          # stack.push($t0)
    sw $t1, 4($sp)          # stack.push($t1)
    sw $t2, 0($sp)          # stack.push($t2)

    la $t0, array           # int *p = &array[0]
    li $t1, 0               # int counter = 0
    li $t2, 10              # int limit = 10

    loop_2:
        li $v0, 1
        lb $a0, 0($t0)      # load each element into $a0 for printing
        syscall             # print each element

        li $v0, 11
        li $a0, 10
        syscall             # print newline character

        addi $t0, $t0, 4    # p += 4 to point to next element
        addi $t1, $t1, 1    # counter++
    blt $t1, $t2, loop_2      # loop while counter < limit

    lw $t2, 0($sp)          # stack.pop($t2)
    lw $t1, 4($sp)          # stack.pop($t1)
    lw $t0, 8($sp)          # stack.pop($t0)
    addi $sp, $sp, 12       # deallocate stack space
    
    jr $ra                  # return to caller

sort:       # bubble sort
    addi $sp, $sp, -28      # allocate space for 7 registers on the stack
    sw $s2, 24($sp)         # stack.push($s2)
    sw $s1, 20($sp)         # stack.push($s1)
    sw $s0, 16($sp)         # stack.push($s0)
    sw $t3, 12($sp)         # stack.push($t3)
    sw $t2, 8($sp)          # stack.push($t2)
    sw $t1, 4($sp)          # stack.push($t1)
    sw $t0, 0($sp)          # stack.push($t0)

    li $t0, 9               # int outer_limit = 9
    li $t1, 0               # int outer_count = 0

    li $t2, 10              # int inner_limit = 10

    la $s0, array           # int *p = &array[0]

    outer_loop:
        add $t3, $t1, 1     # inner_count = outer_count + 1
        inner_loop:
            
            lb $s1, 0($s0)       # *p
            lb $s2, 4($s0)       # *q = p + 1

            ble $s1, $s2, continue

            # if *q < *p, swap *q and *p
            sb $s1, 4($s0)
            sb $s2, 0($s0)

        continue:
            addi $s0, $s0, 4    # p++
            addi $t3, $t3, 1    # inner_count++
        blt $t3, $t2, inner_loop    # iterate while inner_count < inner_limit

        addi $t1, $t1, 1    # outer_count++
        la $s0, array       # reset p to beginning of array for next traversal of array
    blt $t1, $t0, outer_loop # iterate while outer_count < outer_limit

    lw $t0, 0($sp)          # stack.pop($t0)
    lw $t1, 4($sp)          # stack.pop($t1)
    lw $t2, 8($sp)          # stack.pop($t2)
    lw $t3, 12($sp)         # stack.pop($t3)
    lw $s0, 16($sp)         # stack.pop($s0)
    lw $s1, 20($sp)         # stack.pop($s1)
    lw $s2, 24($sp)         # stack.pop($s2)
    addi $sp, $sp, 28       # deallocate stack space

    jr $ra                  # return to caller

terminate:
        li $v0, 10
        syscall


Enter ten integers, one followed by the Enter key. 
Enter an integer: 7
Enter an integer: 3
Enter an integer: 8
Enter an integer: -9
Enter an integer: 4
Enter an integer: 6
Enter an integer: -13
Enter an integer: 2
Enter an integer: 1
Enter an integer: 5

Input array before sorting: 
7
3
8
-9
4
6
-13
2
1
5

Input array after sorting: 
-13
-9
1
2
3
4
5
6
7
8


# 2. Write a MIPS assembly-language program that does the following:
#       a. Reads an entire character string in one go
#       b. Prints the string out in reverse order.
#    Be sure to include MEANINGFUL commments in your code.

.data
        prompt: .asciiz "Please enter a string: "
        out_msg: .asciiz "\nThe reversed string is: "

        MAX_LENGTH: .word 100  # #define MAX_LENGTH 100

        buffer: .space 102     # allocate 102 bytes for 102 chars; 1 byte for each char; 102 including the newline character & null terminator
.text
main:
        jal read_string

        jal input_length
        
        move $a0, $v0       # move pointer returned by input_length to $a0, as it will be used as an input argument for print_reverse_string
        move $a1, $v1       # move index returned by input_length to $a1, for the same reason as above
        jal print_reverse_string

        j terminate

read_string:
        addi $sp, $sp, -12  # allocate space for 3 registers on the stack
        sw $t0, 8($sp)      # stack.push($t0)
        sw $t1, 4($sp)      # stack.push($t1)
        sw $t2, 0($sp)      # stack.push($t2)

        li $v0, 4
        la $a0, prompt
        syscall             # load & print input prompt

        la $a0, buffer      # provide address of buffer as an input argument for "read string"
        lw $a1, MAX_LENGTH  # provide MAX_LENGTH as an input argument for "read string"
        li $v0, 8           # load immediate syscode 8, for "read string"
        syscall             # read string

        lw $t2, 0($sp)      # stack.pop($t2)
        lw $t1, 4($sp)      # stack.pop($t1)
        lw $t0, 8($sp)      # stack.pop($t0)
        addi $sp, $sp, 12   # deallocate stack space

        jr $ra              # return to caller (main)

# @return
#   $v0: a pointer to the null character in the string
#   $v1: the index of the null character in the string
# Initializes a pointer and an index at the beginning of the array,
# and increments the pointer and index until the null terminator is reached.
input_length:
        addi $sp, $sp, -12  # allocate space for 3 registers on the stack
        sw $t0, 8($sp)      # stack.push($t0)
        sw $t1, 4($sp)      # stack.push($t1)
        sw $t2, 0($sp)      # stack.push($t2)

        la $t0, buffer      # initialize a pointer to the beginning of the string
        li $t1, 0           # int index = 0;

        traverse_str:
            lb $t2, 0($t0)  # dereference a character at the index denoted by $t0
            addi $t0, $t0, 1  # pointer++
            addi $t1, $t1, 1  # index++
        bnez $t2, traverse_str # continue looping while char at index != '\0'

        move $v0, $t0       # move pointer to $v0
        move $v1, $t1       # move index to $v1

        lw $t2, 0($sp)      # stack.pop($t2)
        lw $t1, 4($sp)      # stack.pop($t1)
        lw $t0, 8($sp)      # stack.pop($t0)
        addi $sp, $sp, 12   # deallocate stack space

        jr $ra              # return to caller (main)

#  @param
#       $a0: a pointer to the null character in the string
#       $a1: the index of the null character in the string
# Takes in the aforementioned pointer and index, updated by input_length, as arguments, 
# and shifts them to the last non-null character (i.e., third-last character).
# Prints a character denoted by the pointer, and then decrements the pointer and index until the index becomes 0.
#
#   Buffer contents after reading a string "Hello World":
#   H e l l o  W o r l d \n \0
#   To reverse the string, begin at the third-last element and traverse the buffer until index 0.
#   
#   Result: d l r o W  o l l e H
print_reverse_string:
        addi $sp, $sp, -12  # allocate space for 3 registers on the stack
        sw $t0, 8($sp)      # stack.push($t0)
        sw $t1, 4($sp)      # stack.push($t1)
        sw $t2, 0($sp)      # stack.push($t2)

        move $t0, $a0       # move pointer from $a0 to $t0, as it will be modified within this function
        move $t1, $a1       # move index from $a1 to $t1, for the same reason

        addi $t0, $t0, -2   # decrement pointer by 2, to exclude the newline and null character at the end
        addi $t1, $t1, -2   # decrement index by 2, for the same reason

        li $v0, 4
        la $a0, out_msg
        syscall             # load & print output message

        traverse_str2:
            lb $t2, 0($t0)  # dereference a character denoted by the pointer
            beqz $t2, terminate  # exit if the character is null

            li $v0, 11
            move $a0, $t2
            syscall         # print the character

            addi $t0, $t0, -1       # pointer--
            addi $t1, $t1, -1       # index--
        bgez $t1, traverse_str2     # continue looping while index >= 0

        li $v0, 11
        li $a0, 10
        syscall             # load & print newline character

        lw $t2, 0($sp)      # stack.pop($t2)
        lw $t1, 4($sp)      # stack.pop($t1)
        lw $t0, 8($sp)      # stack.pop($t0)
        addi $sp, $sp, 12   # deallocate stack space

        jr $ra              # return to caller (main)

terminate:                  # terminate execution
        li $v0, 10
        syscall


Please enter a string: Hello World!

The reversed string is: 
!dlroW olleH

