Wooyoung Jung 114744214- CSE220 Assignment 8

# 1. Write a MIPS assembly-language function that divides two positive numbers and returns the quotient and remainder.
# 	a. The dividend and divisor should be passed in $a0 and $a1.
# 	b. The quotient and remainder should be returned in $v0 and $v1.
# 	c. Other than result registers, any registers whose contents are modified should have contents saved and restored appropriately.
#
# 	Write a "main" that appropriately tests the function.
#
# 	Be sure to include meaningful comments in your code.

.data
	prompt: .asciiz "\nEnter a positive dividend and divisor, each followed by the Enter key: \n"
	out_quotient: .asciiz "The quotient is: "
	out_remainder: .asciiz "The remainder is: "

.text
main:
	la $a0, prompt
	li $v0, 4
	syscall		# load and print input prompt

	li $v0, 5
	syscall		# read input into $v0
	move $a0, $v0	# move input (dividend) to $a0 to pass as an argument for divide

	li $v0, 5
	syscall		# read input into $v0
	move $a1, $v0  	# move input (divisor) to $a1 to pass as an argument for divide

	jal divide	# jump and link to divide function

	move $t0, $v0	# move return value in $v0 (quotient) to $t0 for temporary storage
	move $t1, $v1	# move return value in $v1 (remainder) to $t1 for temporary storage

	la $a0, out_quotient
	li $v0, 4
	syscall		# load and print output message for quotient

	li $v0, 1
	move $a0, $t0
	syscall		# move quotient stored in $t0 to $a0 and print

	li $v0, 11
	li $a0, 10
	syscall		# load and print newline character

	la $a0, out_remainder
	li $v0, 4
	syscall		# load and print output message for remainder

	li $v0, 1
	move $a0, $t1	# move remainder stored in $t1 to $a0 and print
	syscall

	li $v0, 11
	li $a0, 10
	syscall		# load and print newline character

	j terminate	# terminate execution

divide:
	addi $sp, $sp, -12	# allocate stack space for 3 registers
	sw $a0, 8($sp)		# stack.push($a0)
	sw $a1, 4($sp)		# stack.push($a1)
	sw $ra, 0($sp)		# stack.push($ra)
	
	move $s0, $a0		# save dividend in $s0, the scope of the entire function
	addi $s2, $s2, 0	# int quotient = 0

	bge $a0, $a1, else
	li $v0, 0
	move $v1, $a0		# base case: if dividend < divisor, return 0 as the quotient and dividend as the remainder

	addi $sp, $sp, 12	# deallocate stack space
	jr $ra			# return base case

	else:			# if dividend >= divisor, proceed to recursive case
		addi $s2, $s2, 1	# quotient++
		sub $s0, $s0, $a1	# dividend = dividend - divisor
		move $a0, $s0
		jal divide		# recursive call: divide (dividend - divisor, divisor)

		lw $ra, 0($sp)	# stack.pop($ra)
		lw $a1, 4($sp)	# stack.pop($a1)
		lw $a0, 8($sp)	# stack.pop($a0)
		addi $sp, $sp, 12 # deallocate stack space
		move $v0, $s2	# move quotient to return register
		move $v1, $s0	# move remainder to return register
	
		jr $ra			# return recursive case

terminate:
	li $v0, 10
	syscall


Enter a positive dividend and divisor, each followed by the Enter key: 
13
3
The quotient is: 4
The remainder is: 1


# 2. Write a MIPS assembly-language function that counts the number of times a given number appears in an array.
#	@param
# 		$a0: base address of the array
# 		$a1: length of the array
# 		$a2: the number to be searched
# 	@return
# 		$v0: result of the search, i.e., number of occurrences of the given number in the array

.data
	array: .word 1, 2, 2, 2, 4, 2, 5, 2, 6
	out_msg: .asciiz "\nThe number of occurrences of the number 2 in the array is: " # result must be 5

.text
main:
	la $a0, out_msg
	li $v0, 4
	syscall

	la $a0, array
	li $a1, 9
	li $a2, 2
	jal num_occurrences	# call function

	move $a0, $v0
	li $v0, 1
	syscall			# load and print number of occurrences returned by the function

	li $v0, 11
	li $a0, 10
	syscall			# printf("%c", '\n');

	li $v0, 10
	syscall

num_occurrences:
	addi $sp, $sp, -20	# allocate space for 5 registers
	sw $ra, 0($sp)		# stack.push($ra)
	sw $a0, 4($sp)		# stack.push($a0)
	sw $a1, 8($sp)		# stack.push($a1)
	sw $a2, 12($sp)		# stack.push($a2)
	sw $t0, 16($sp)		# stack.push($t0)

	li $t0, 1		# load 1 into $t0 for comparison
	beq $a1, $t0, base	# if length == 1, jump to base case
	j recur			# else, jump to recursive case

	base:
		lw $t0, 0($a0)	# dereference pointer and store in $t0
		beq $t0, $a2, one
		j zero
		one:
			li $v0, 1 # return 1 if *array == num
			j done
		zero:
			li $v0, 0 # else return 0
			j done

	recur:
		addi $a0, $a0, 4 # pointer + 4
		addi $a1, $a1, -1 # length - 1
		jal num_occurrences # recursive call
		lw $t0, 0($a0)      # dereference next character
		beq $t0, $a2, incr  # increment count if *array == num
		j done

	incr:
			addi $v0, $v0, 1  # count += 1

	done:
		lw $t0, 16($sp)
		lw $a2, 12($sp)
		lw $a1, 8($sp)
		lw $a0, 4($sp)
		lw $ra, 0($sp) # pop registers from stack
		addi $sp, $sp, 20 # deallocate stack space
		jr $ra # return


The number of occurrences of the number 2 in the array is: 5


# 3. Write a MIPS assemly-language version of the strcmp function in C.
# 	@param
# 		$a0: base address of the first string (char* s1)
# 		$a1: base address of the second string (char* s2)
# 	@return
# 		$v0: lexicographical comparison of the two strings;
# 			s1 > s2 -> 1
# 			s1 == s2 -> 0
# 			s1 < s2 -> -1

.data
	s1: .asciiz "Hello"
	s2: .asciiz "Hellong"

	out_msg: .asciiz "\nLexicographical comparison of the two strings: "

.text
main:
	la $a0, s1
	la $a1, s2	# load s1 and s2 into argument registers for strcmp

	jal strcmp	# call strcmp

	move $t0, $v0	# store return value of strcmp in $t0

	li $v0, 4
	la $a0, out_msg
	syscall

	li $v0, 1
	move $a0, $t0
	syscall

	li $v0, 10
	syscall

strcmp:
	addi $sp, $sp, -16
	sw $a0, 0($sp)
	sw $a1, 4($sp)
	sw $t0, 8($sp)
	sw $t1, 12($sp)		# allocate stack space and store 4 registers

	loop:
		lb $t0, 0($a0)
		lb $t1, 0($a1)	# dereference s1 and s2

		bgt $t0, $t1, one
		blt $t0, $t1, neg_one

		bne $t0, $0, incr_s1
		bne $t1, $0, incr_s2

		equals: li $v0, 0
			j done

		incr_s1:
			addi $a0, $a0, 1
			bne $t1, 0, incr_s2
			j loop
		incr_s2:
			addi $a1, $a1, 1
			j loop
		one:
			li $v0, 1
			j done
		neg_one:
			li $v0, -1
			j done

	done:	lw $t1, 12($sp)
		lw $t0, 8($sp)
		lw $a1, 4($sp)
		lw $a0, 0($sp)
		addi $sp, $sp, 16	# load 4 registers and deallocate stack space
		jr $ra			# return


Lexicographical comparison of the two strings: -1


