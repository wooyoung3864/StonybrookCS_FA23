/**
 * 1. Write a function, Sort, that takes three parameters-- an array, the size of the array, and the number of the actual elements in the array-- reads in some integers, and sorts them:
 * 	void Sort(int a[], int n, int m)
 *    Call the function from main to test it; n should be greater than m, and the elements read should be sorted into the first m slots of the array.
 */

#include <stdio.h>

void sort(int a[], int n, int m);

int main(void) {
	int m, n, i;
	printf("Enter size of array: ");
	scanf("%d", &n);
	printf("Enter number of elements in array: ");
	scanf("%d", &m);
	
	int a[n];

	for(i = 0; i < m; i++) {
		printf("Enter a number: ");
		scanf("%d", &a[i]);
	}

	sort(a, n, m);

	printf("Sorted array: ");
	for(i = 0; i < m; i++) printf("%d ", a[i]);
	printf("\n");

	return 0;
}

void sort(int a[], int n, int m) {
	int i, j;

	for(i = 0; i < n; i++) {
		for(j = i+1; j < n; j++) {
			if(a[j] < a[i]) {
				int temp = a[i];
				a[i] = a[j];
				a[j] = temp;
			}
		}
	}
}



/** 2. Write a function, Insert, that takes the same parameters as in (1) plus an additional integer, x, and inserts x in the correct position in a sorted array. 
 *     
 *     Write test code that first calls Sort to sort the array and then calls Insert to do an insertion.
 */

#include <assert.h>
#include <stdio.h>

void sort(int a[], int m, int n);
void insert(int a[], int m, int n, int x);

int main(void) {
	int i, m, n, x;
	
	printf("Enter size of array: ");
	scanf("%d", &n);

	printf("Enter number of elements in array: ");
	scanf("%d", &m);
	assert(n > m);

	int a[n];

	for(i = 0; i < m; i++) {
		printf("Enter a number: ");
		scanf("%d", &a[i]);
	}

	sort(a, m, n);

	printf("Enter number to insert into array: ");
	scanf("%d", &x);
	insert(a, m, n, x);

	printf("Array with inserted number: ");
	for(i = 0; i <= m; i++) printf("%d ", a[i]);
	
	printf("\n");

	return 0;
	}

void sort(int a[], int m, int n) { // I thought of this sorting algorithm in my head and used it because it was simple. 
					// Suboptimal time complexity; could be improved by implementing a more efficient algorithm such as Merge Sort.
	int i, j;

	for(i = 0; i < m; i++) {
		for(j = i+1; j < m; j++) {
			if(a[j] < a[i]) {
				int temp = a[i];
				a[i] = a[j];
				a[j] = temp;
			}
		}
	}
}

void insert(int a[], int m, int n, int x) { // precondition: a is sorted using sort(), 
						// n > m; this suggests that there is always extra space to shift elements to the right by 1 and insert x
	int insert_index, i; // insertion index and i as for-loop index

	if(x <= a[0]) insert_index = 0; // if x <= min, insert x at 0
	else if(x>= a[m-1]) insert_index = m; // if x >= max, insert x at m
	else {
		for(i = 0; i < m-1; i++) {
			if( (x >= a[i]) && (x < a[i+1]) ) { // find an index such that x is >= current element and < next element
				insert_index = i+1;
				break;
			}
		}
	}

	for(i = m; i > insert_index - 1; i--) { // shift all elements after insert_index to the right by 1
		a[i] = a[i-1]; 
	}

	a[insert_index] = x; // insert x at insert_index after shifting everything else to the right by 1
}



/** 3. Write a function to find the number of occurrences of integers in an array of ten elements. For example, with the array { 8, 3, 8, 5, 4, 3, 4, 3, 5, 9 }, the output should be 
 * 	8:2
 * 	3:3
 * 	5:2
 * 	4:2
 *      9:1
 *     Write a main to test the function appropriately.
 */

#include <stdio.h>
#define N 10

void sort(int arr[], int size);
void num_occurrences(int arr[], int size);

int main(void) {
	int arr[N] = { 8, 3, 8, 5, 4, 3, 4, 3, 5, 9 };
	
	printf("Input array: \n");
	for(int i = 0; i < N; i++) printf("%d ", arr[i]);
	printf("\n");

	num_occurrences(arr, N);

	return 0;
}

void sort(int arr[], int size) {
	int i, j;

	for(i = 0; i < size; i++) {
		for(j = i+1; j < size; j++) {
			if(arr[j] < arr[i]) {
				int temp = arr[i];
				arr[i] = arr[j];
				arr[j] = temp;
			}
		}
	}
}

void num_occurrences(int arr[], int size) {
	sort(arr, size); // sorts arr in ascending order first so that identical elements are grouped together.
			
	int i = 0, j, num_unique = 0;

	/** Compares adjacent elements using two nested loops; the for-loop with index j traverses the subarray spanning i to size-1 and compares arr[j] to arr[i].
	 *  Increments num_unique when a repeated occurrence of an element at i is encountered.
	 *  Increments i by num_unique so that it skips to the next unique element, and resets num_unique to 0 so that it can count occurrences of the next unique element.
	 */
	while(i < size) {
		for(j = i; j < size; j++) {
			if(arr[i] == arr[j]) num_unique++; // increments num_unique
		}

		printf("Number of unique occurrences of %d: %d\n", arr[i], num_unique);
		i += num_unique; // increments i by num_unique
		num_unique = 0; // resets num_unique to 0
	}
}


/** 4. Repeat (3), but with code that uses pointers instead of array subscripting (i.e., indexing).
 */

#include <stdio.h>
#define N 10

void ptr_sort(int arr[], int size);
void ptr_num_occurrences(int arr[], int size);

int main(void) {
	int arr[N] = { 8, 3, 8, 5, 4, 3, 4, 3, 5, 9 };
	
	printf("Input array: \n");
	for(int i = 0; i < N; i++) printf("%d ", arr[i]);
	printf("\n");

	ptr_num_occurrences(arr, N);

	return 0;
}

void ptr_sort(int arr[], int size) {
	int *p, *q, temp;

	for(p = arr; p < arr + size; p++) {
		for(q = p+1; q < arr + size; q++) {
			if(*q < *p) {
				temp = *p;
				*p = *q;
				*q = temp;
			}
		}
	}
}

void ptr_num_occurrences(int arr[], int size) {
	ptr_sort(arr, size);

	int *p = &arr[0], *q, num_unique = 0;

	while(p < arr + size) {
		for(q = arr; q < arr + size; q++) {
			if(*p == *q) num_unique++;
		}
		printf("Number of unique occurrences of %d: %d\n", *p, num_unique);
		p += num_unique;
		num_unique = 0;
	}
}



/** 5. Write a function whose arguments are an integer N and a matrix (i.e., two-dimensional array), of N by N integers and whose actions are to transpose the matrix. 
 *  Write a main to test the function with a small matrix.
 */

#include <stdio.h>
#define N 3

void transpose(int n, int arr[n][n]);

int main(void) {
	int arr[N][N] = { {2, 1, 2}, {3, 5, 7}, {-13, -9, 0} }; // transpose(arr) should be { {2, 3, -13}, {1, 5, -9}, {2, 7, 0} }

	printf("Original matrix: \n");
	for(int i = 0; i < N; i++) {
		for(int j = 0; j < N; j++) {
			printf("%d\t", arr[i][j]);
		}
		printf("\n");
	}
	
	transpose(N, arr);
	printf("Transposed matrix: \n");
	for(int i = 0; i < N; i++) {
		for(int j = 0; j < N; j++) {
			printf("%d\t", arr[i][j]);
		}
		printf("\n");
	}

	return 0;
}

void transpose(int n, int arr[n][n]) {
	int i, j, temp;

	for(i = 0; i < n; i++) {
		for(j = i; j < n; j++) {
			if(i == j) continue; // elements on the main diagonal do not have to be swapped.
			temp = arr[i][j];
			arr[i][j] = arr[j][i];
			arr[j][i] = temp;
		}
	}
}


